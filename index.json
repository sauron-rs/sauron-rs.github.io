[
  {
    "title": "Sauron Architecture",
    "url": "/Architecture.html",
    "body": "# Sauron Architecture\n\nSauron programs always look something like this:\n\n```bob\n     .-------- Node ---------.\n    |                        |\n    |                        |\n    |                        V\n.--------.                .----------.\n| sauron |                | web      |\n`--------'                |   page   |\n    ^                     `----------'\n    |                        |\n     \\                      /\n      `-------- Msg -------'\n```\nSauron program produces html Node tree to show on the screen.\nEvents are sent back as messages of what is going on. \"They clicked a button!\"\n\nWhat happens within the sauron program through? It always breaks into 3 parts.\n- model - the state of you application\n- view - a way to turn your state into Html nodes.\n- update - a way to update your  state based on messages.\n\nSauron provides `Application` trait which lets you implement a `view` and `update` of the `Model` of your application.\nThese 3 methods are the core of sauron web framework.\n\nThe next few examples are going to show how to use this pattern for user input, like buttons and text fields. It will make this\nmuch more concrete!\n"
  },
  {
    "title": "Untitled",
    "url": "/Architecture/Buttons.html",
    "body": "## Buttons\n\nOur first example is a counter that can be incremented or decremented.\n\nI included the full program below.\n\nPut this into `src/lib.rs`.\n```rust\nuse sauron::prelude::*;\n\n#[derive(Debug)]\npub enum Msg {\n    Increment,\n    Decrement,\n}\n\npub struct App {\n    count: i32,\n}\n\nimpl App {\n    pub fn new() -> Self {\n        App { count: 0 }\n    }\n}\n\nimpl Application<Msg> for App {\n    fn view(&self) -> Node<Msg> {\n        node! {\n            <main>\n                <input type=\"button\"\n                    value=\"+\"\n                    key=\"inc\"\n                    on_click=|_| {\n                        Msg::Increment\n                    }\n                />\n                <div class=\"count\">{text(self.count)}</div>\n                <input type=\"button\"\n                    value=\"-\"\n                    key=\"dec\"\n                    on_click=|_| {\n                        Msg::Decrement\n                    }\n                />\n            </main>\n        }\n    }\n\n    fn update(&mut self, msg: Msg) -> Cmd<Self, Msg> {\n        match msg {\n            Msg::Increment => self.count += 1,\n            Msg::Decrement => self.count -= 1,\n        }\n        Cmd::none()\n    }\n}\n\n#[wasm_bindgen(start)]\npub fn main() {\n    Program::mount_to_body(App::new());\n}\n```\nPut this into your `Cargo.toml`.\n```toml\n[package]\nname = \"counter\"\nversion = \"0.1.0\"\nauthors = [\"Jovansonlee Cesar <ivanceras@gmail.com>\"]\nedition = \"2018\"\n\n[lib]\ncrate-type = [\"cdylib\"]\n\n[dependencies]\nsauron = \"0.43\"\n```\n\nPut this into you `index.html`.\n```html\n<html>\n  <head>\n    <meta content=\"text/html;charset=utf-8\" http-equiv=\"Content-Type\"/>\n    <title>Counter</title>\n    <style type=\"text/css\">\n        body { font-family: verdana, arial, monospace; }\n        main {\n            width:30px;\n            height: 100px;\n            margin:auto;\n            text-align: center;\n        }\n        input, .count{\n            font-size: 40px;\n            padding: 30px;\n        }\n    </style>\n    <script type=module>\n        import init from './pkg/counter.js';\n        await init().catch(console.error);\n    </script>\n  </head>\n  <body>\n  </body>\n</html>\n```\n\nCompile the project using:\n```\nwasm-pack build --release --target=web\n```\nThis will produce files in `pkg` directory, with names derived from the crate name.\nIn this case `pkg/counter.js` and `pkg/counter_bg.wasm`.\n\n## Main\nThe `main` function here is the entry point of our application. The function doesn't have to be named\n`main` as long as it is anotated with `#[(wasm_bindgen(start)]`.\nIt tells the the runtime on where to display the application. In this case,\nwe are going to initialize our application by calling it's `fn new()->Self` method.\nThe `view` function is going to show everything on screen, and user input is going to be fed\ninto the `update` function. Think of this as the high-level description of our program.\n\n```rust\n#[wasm_bindgen(start)]\npub fn main() {\n    Program::mount_to_body(App::new());\n}\n```\n\n## Model\nData modeling is extremely important in Elm. The point of the mode is to capture all the details\nabout your application as data.\n\nTo make a counter, we need to keep track of a number that is going up and down.\nThat means our model is really small this time:\n\n```rust\npub struct App {\n    count: i32,\n}\n```\n\nWe just need an `i32` value to track the current count. We can see that in out initial value:\n```rust\nimpl App {\n    pub fn new() -> Self {\n        App { count: 0 }\n    }\n}\n```\nThe initial value is zero, and it will go up and down as people press different buttons.\n\n## View\nWe have a model, but how do we show it on screen? The is the role of the `view` function:\n```rust\nimpl Application<Msg> for App {\n    fn view(&self) -> Node<Msg> {\n        node! {\n            <main>\n                <input type=\"button\"\n                    value=\"+\"\n                    key=\"inc\"\n                    on_click=|_| {\n                        Msg::Increment\n                    }\n                />\n                <div class=\"count\">{text(self.count)}</div>\n                <input type=\"button\"\n                    value=\"-\"\n                    key=\"dec\"\n                    on_click=|_| {\n                        Msg::Decrement\n                    }\n                />\n            </main>\n        }\n    }\n}\n```\nThis function takes in the `App` as an argument. It outputs HTML. So we are saying that we want\nto show a decrement button, the current count, and an increment button.\n\nNotice that we have an `on_click` handler for each button. These are saying:\n*when someone clicks, generate a message*. So the plus button is generating an `Increment` message.\nWhat is that and where does it go? To the `update` function!\n\n## Update\n\nThe `update` function describes how our `Model` will change over time.\nWe defined 2 messages that it might receive:\n```rust\n#[derive(Debug)]\npub enum Msg {\n    Increment,\n    Decrement,\n}\n```\nFrom there, the `update` function just describes what to do when you receive one of these messages.\n\n```rust\nimpl Application<Msg> for App {\n    fn update(&mut self, msg: Msg) -> Cmd<Self, Msg> {\n        match msg {\n            Msg::Increment => self.count += 1,\n            Msg::Decrement => self.count -= 1,\n        }\n        Cmd::none()\n    }\n}\n```\nIf you get an `Increment` message, you increment the model. If you get a `Decrement` message,\nyou decrement the model.\n\nSo whenever we get a message, we run it through `update` to get a new model.\nWe then call the `view` to figure out how to show the new model on screen.\nThen repeat! User input generates a message, `update` the model, `view` it on screen. Etc.\n\n## Overview\nNow that you have seen all the parts of a Sauron program, it may be a bit easier to see how they\nfit into the diagram we saw earlier:\n\n```bob\n     .-------- Node ---------.\n    |                        |\n    |                        |\n    |                        V\n.--------.                .----------.\n| sauron |                | web      |\n`--------'                |   page   |\n    ^                     `----------'\n    |                        |\n     \\                      /\n      `-------- Msg -------'\n```\nSauron starts by rendering the initial value on screen. From there you enter into this loop:\n1. Wait for user input.\n2. Send a message to `update`\n3. Produce a new `Model`\n4. Call `view` to get a new HTML\n5. Show the new HTML on screen.\n6. Repeat.\n\nThis is the essence of Sauron archicture. Every example we see from now on will be a slight\nvariation on this basic pattern.\n\nExercise: Add a button to reset the counter to zero:\n1. Add a `Reset` variant to the `Msg` type.\n2. Add a `Reset` branch in the `update` function\n3. Add a button in the `view` function.\n"
  },
  {
    "title": "Cmd",
    "url": "/Architecture/Cmd.html",
    "body": "# Cmd\n\nSauron has a runtime system where it executes commands.\n\nA command is a way of telling Sauron, \"Hey, I want you to do this thing!\".\nSo if you want to send an HTTP request, you would need to command Sauron to do it.\n\nEvery `Cmd` specifis which effects you need to do the application and the type of messages that will come back into your application.\n"
  },
  {
    "title": "Quickstart",
    "url": "/Architecture/Quickstart.html",
    "body": "# Quickstart\n\nOur first example is a counter that can be incremented or decremented.\nThe complete code is found [here](https://github.com/ivanceras/sauron/tree/master/examples/counter)\n\n\nI assume you already installed rust and cargo binaries already.\nIf not, then you can install by issuing the following command from your terminal.\n\n```sh\ncurl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs | sh\n```\n\n\nTo create a rust project with sub code in it. Issue the command:\n```sh\ncargo new --lib counter\n```\nThis will create a library crate with `counter` as the package name.\n\nEdit the `Cargo.toml` file to set the library crate-type to `cdylib`[^0].\n\n\n```toml\n[package]\nname = \"counter\"\nversion = \"0.1.0\"\nauthors = [\"Your name <urmail@provider.domain>\"]\nedition = \"2018\"\n\n[lib]\ncrate-type = [\"cdylib\"]\n\n\n[dependencies]\nsauron = \"0.32\"\n```\n\nWe also need to add `sauron` as a dependecy of the project.\n\n\nAdd this code to `src/lib.rs`\n\n`src/lib.rs`\n\n```rust\nuse sauron::html::text;\nuse sauron::prelude::*;\nuse sauron::{node, Cmd, Component, Node, Program};\n\n#[derive(Debug)]\npub enum Msg {\n    Increment,\n    Decrement,\n}\n\npub struct App {\n    count: i32,\n}\n\nimpl App {\n    pub fn new() -> Self {\n        App { count: 0 }\n    }\n}\n\nimpl Component<Msg> for App {\n    fn view(&self) -> Node<Msg> {\n        node! {\n            <main>\n                <input type=\"button\"\n                    value=\"+\"\n                    key=\"inc\"\n                    on_click=|_| {\n                        Msg::Increment\n                    }\n                />\n                <div>{text(self.count)}</div>\n                <input type=\"button\"\n                    value=\"-\"\n                    key=\"dec\"\n                    on_click=|_| {\n                        Msg::Decrement\n                    }\n                />\n            </main>\n        }\n    }\n\n    fn update(&mut self, msg: Msg) -> Cmd<Self, Msg> {\n        match msg {\n            Msg::Increment => self.count += 1,\n            Msg::Decrement => self.count -= 1,\n        }\n        Cmd::none()\n    }\n}\n\n#[wasm_bindgen(start)]\npub fn main() {\n    Program::mount_to_body(App::new());\n}\n```\n\nAnd finally our `index.html` file\n```html\n<html>\n  <head>\n    <meta content=\"text/html;charset=utf-8\" http-equiv=\"Content-Type\"/>\n    <title>Counter</title>\n  </head>\n  <body>\n    <script type=module>\n        import init from './pkg/counter.js';\n        init().catch(console.error);\n    </script>\n  </body>\n</html>\n```\n\nThis is the minimal set of files in order to compile and run our project as a web application.\nNext, we need to install [`wasm-pack`](https://crates.io/crates/wasm-pack), to simplify our workflow of our project to compile to webassembly.\n```sh\ncargo install wasm-pack\n```\n\nInvoking the command:\n```sh\nwasm-pack build --release --target=web\n```\n`wasm-pack` adds arguments to the rust compiler to compile our code into webassembly and link it to a javascript module.\nAll of this is abstracted with `wasm-pack`, so we don't have to think about it.\nWe only care about our js file `./pkg/counter.js` that is generated in `pkg` directory in our project folder.\n\nNext, we need to statically serve the `index.html` such that the browser can run the `.wasm`[^wasm] binary in the browser\n\n[^0]: use `cdylib` for crate-type if you want to build it as wasm entry point crate.\nIf you also want this crate as a reusable component from your other crate, then you can add `rlib` as crate-type.\n\n    ```toml\n     [lib]\n    crate-type = [\"cdylib\", \"rlib\"]\n    ```\n\n[^wasm]: `wasm` files can not be executed in the browser unless serve from the same domain as the `index.html` which reference it.\n\n"
  },
  {
    "title": "Writing the view",
    "url": "/Architecture/View.html",
    "body": "# Writing the view\n\nThere are 2 major way to write views in sauron.\nThe first one is using the `node!` macro which allows you to write an html like syntax.\nThe second one is using function call. They have no difference in performance.\n\n\nListing 1: Building the view method using `node!` macro.\n```rust\nimpl App{\n    fn view(&self) -> Node<Msg>{\n        node!{\n            <div id=\"app\" class=\"container\">\n                <ul class=\"list\">\n                    <li>\"item 1\"</li>\n                    <li>\"item 2\"</li>\n                    <li>\"item 3\"</li>\n                </ul>\n            </div>\n        }\n    }\n    // --snip--\n}\n```\nThe first listing very closely resembles html code.\n\nListing 2: Building the view using function calls.\n```rust\nimpl App{\n    fn view(&self) -> Node<Msg>{\n        div([id(\"app\"), class(\"container\")], [\n            ul([class(\"list\")],[\n                li([], [text(\"item 1\")]),\n                li([], [text(\"item 2\")]),\n                li([], [text(\"item 3\")]),\n            ])\n        ])\n    }\n    // --snip--\n}\n```\nThe second listing is a normal function call to build a DOM tree using the pattern.\n```rust\n\n<tag_name>([<attributes>], [children_node])\n\n```\nThe function name is the tag of the html. The first argument is an array/vec of attributes.\nThe second argument is an array/vec of child nodes.\n\nAttributes can be created using the pattern.\n```rust\n\n<attribute_name>(value)\n\n```\nThe function name is the attribute name and the first argument is the attribute value.\n\nI personally prefer the 2nd option for 2 reasons.\n- `cargo fmt` for free, and aligns your code nicely.\n- The code is a bit shorter than using the macro syntax.\n"
  },
  {
    "title": "A Quick Example",
    "url": "/Introduction.html",
    "body": "# Introduction\n\nSauron is a web framework written in rust, which can compile to webassembly to help you create robust websites and web apps.\n\nThis guide will:\n- Show you how to make interactive apps with Sauron web framework.\n\n# A Quick Example\n\n```rust\nuse sauron::html::text;\nuse sauron::prelude::*;\nuse sauron::{node, Cmd, Component, Node, Program};\n\n#[derive(Debug)]\npub enum Msg {\n    Increment,\n    Decrement,\n}\n\npub struct App {\n    count: i32,\n}\n\nimpl App {\n    pub fn new() -> Self {\n        App { count: 0 }\n    }\n}\n\nimpl Component<Msg> for App {\n    fn view(&self) -> Node<Msg> {\n        node! {\n            <main>\n                <input type=\"button\"\n                    value=\"+\"\n                    key=1\n                    on_click={|_| {\n                        Msg::Increment\n                    }}\n                />\n                <div>{text(self.count)}</div>\n                <input type=\"button\"\n                    value=\"-\"\n                    key=1\n                    on_click={|_| {\n                        Msg::Decrement\n                    }}\n                />\n            </main>\n        }\n    }\n\n    fn update(&mut self, msg: Msg) -> Cmd<Self, Msg> {\n        match msg {\n            Msg::Increment => self.count += 1,\n            Msg::Decrement => self.count -= 1,\n        }\n        Cmd::none()\n    }\n}\n\n#[wasm_bindgen(start)]\npub fn main() {\n    console_log::init_with_level(log::Level::Trace).unwrap();\n    console_error_panic_hook::set_once();\n    Program::mount_to_body(App::new());\n}\n```\n\n## Why sauron?\n- No runtime errors in practice\n- Reliable refactoring\n- Automatically enforced semantic versioning for all dependent crates.\n"
  },
  {
    "title": "Untitled",
    "url": "/index.html",
    "body": "Welcome to the sauron wiki!\n\nThis wiki is based on [guide.elm-lang.org](https://guide.elm-lang.org/) adapted for sauron.\n\n- [Introduction](Introduction.md)\n- [Architecture](Architecture.md)\n    - [Quick start](Architecture/Quickstart.md)\n    - [Buttons](Architecture/Buttons.md)\n    - [Cmd](Architecture/Cmd.md)\n    - [View](Architecture/View.md)\n"
  }
]